---
tags: ruby,sort,sort_by
date: 2018-09-21 14:46:31
---

我们都知道 sort_by 的排序效率比 sort 快，但是为什么呢？

### 效率判断指标

标准的 Linux 中有测定程序执行时间的工具，就是 time 命令，用法很简单，命令执行时，只需要在开始加上 time 就行了，如图：

![](http://ogbkru1bq.bkt.clouddn.com/1537512651.png)

time 命令还有多个版本，但是基本包含 3 个指标：

- real(总执行时间)。程序从开始到执行结束的总时间，有时称为 total，或者 elapased（经过时间）
- user（用户消费时间）。程序执行中，用户消费的时间，即程序本身执行的时间。
- sys（系统消费时间）。程序执行中系统调用所花费的时间，有时称为 system。
  程序执行的快慢，虽然可以用 real 来判断，单通过观察 user 与 sys 的比率，可以大体判断出是程序本身执行慢，还是系统调用太多导致程序变慢。

也许你没有意识到，系统调用花费的时间很多，通常程序工作的用户空间与系统调用所工作的内核空间是完全隔离的，所以系统调用需要遵循一下几个步骤

1.  将参数从用户空间复制到内核空间；
2.  执行系统调用的中断程序；
3.  在中断处理内切换到内核空间。

将系统调用的结果返回给用户空间又需要反方向执行这几步，所以有太多的系统调用，会引起性能恶化。

### sort and sort_by

sort_by 之所以比 sort 快，就是因为少了很多次的系统调用，看下面的把当前目录下的文件按照文件最后更新的时间排序的例子：

```ruby
Dir.entries(".").sort do |a,b|
  File.mtime(a) <=> File.mtime(b)
end
```

本程序在测试时，目录下有 4556 个文件，执行结果如下:

![](http://ogbkru1bq.bkt.clouddn.com/1537513791.png)

程序大约执行了 4.6 秒，系统调用时间大约 0.850 秒，约占总时间的 20%，如果减少系统的调用会有多大的效果呢？

首先统计一下程序中`File.mtime()`调用了多少次。在 sort 方法中，如果给出了程序块`{...}`为了排序，每次比较元素时都要调用次块，所以程序块的调用次数比元素的个数要多很多。结果发现比较元素时程序块执行了
78270 次。为了比较 4556 个元素，就调用了 78270 次，太频繁了，美执行一次程序块，都要调用两次`File.mtime()`，总体上要调用 156540 次。

排序任务繁重时，典型的对策是使用施瓦茨变换（Schwarzian Transform），这是 Randal Schwarz 设计的告诉排序算法，先计算出比较用的值，避免比较计算重复进行，施瓦茨变换按以下几个步骤执行

1.  对排序对象的各个元素，计算比较用的值，与元素本身配对，组成一个数组（每个元素是一个二元数组）
2.  将此数组按照以上计算的比较有用值进行比较
3.  从排序后数组的数组中，取出以前的元素

上述步骤可以用一下代码表示

```ruby
Dir.entries(".").map{|x| [x,File.mtime(x)]}
  .sort{|a,b| a[1] <=> b[1]}
  .map{|x| x[0]}
```

稍微有点繁琐，事实上，施瓦茨变换已经内嵌到 sort_by 方法中，使用 sort_by 的程序如下：

```ruby
Dir.entries(".").sort_by{|a| File.mtime(a)}
```

再次测试执行时间

![](http://ogbkru1bq.bkt.clouddn.com/1537514829.png)

总执行时间从 4.624 秒减少到 0.263 秒，用户消费时间从 3.590 秒减少到 0.220 秒，系统时间从 0.850 减少到 0.050 秒，大体上快了 17 倍，用其他方式测定`File.mtime()`执行的次数为 4556 次，大约减少最初的 1/34.

施瓦茨变换通过事先保存反复计算的值来削减了计算量。这是一种成为 Memoize 的高速技术，在计算中，时间和空间可以交换，保存计算结果要占用多余的内存，作为回报能够节省时间。Memoize 在各种情况下都可以用于提高速度。
