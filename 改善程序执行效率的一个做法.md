---
tags: [ruby,sort,sort_by]
date: 2018-09-21 14:46:31
---

> 节选自《松本行弘的程序世界》

我们都知道 sort_by 的排序效率比 sort 快，但是为什么呢？

### 效率判断指标

标准的 Linux 中有测定程序执行时间的工具，就是 time 命令，用法很简单，命令执行时，只需要在开始加上 time 就行了，如图：

![](http://ogbkru1bq.bkt.clouddn.com/1537512651.png)

time 命令还有多个版本，但是基本包含 3 个指标：

- real(总执行时间)。程序从开始到执行结束的总时间，有时称为 total，或者 elapased（经过时间）
- user（用户消费时间）。程序执行中，用户消费的时间，即程序本身执行的时间。
- sys（系统消费时间）。程序执行中系统调用所花费的时间，有时称为 system。
  程序执行的快慢，虽然可以用 real 来判断，单通过观察 user 与 sys 的比率，可以大体判断出是程序本身执行慢，还是系统调用太多导致程序变慢。

也许你没有意识到，系统调用花费的时间很多，通常程序工作的用户空间与系统调用所工作的内核空间是完全隔离的，所以系统调用需要遵循一下几个步骤

1.  将参数从用户空间复制到内核空间；
2.  执行系统调用的中断程序；
3.  在中断处理内切换到内核空间。

将系统调用的结果返回给用户空间又需要反方向执行这几步，所以有太多的系统调用，会引起性能恶化。

### sort and sort_by

sort_by 之所以比 sort 快，就是因为少了很多次的系统调用，看下面的把当前目录下的文件按照文件最后更新的时间排序的例子：

```ruby
Dir.entries(".").sort do |a,b|
  File.mtime(a) <=> File.mtime(b)
end
```

本程序在测试时，目录下有 4556 个文件，执行结果如下:

![](http://ogbkru1bq.bkt.clouddn.com/1537513791.png)

程序大约执行了 4.6 秒，系统调用时间大约 0.850 秒，约占总时间的 20%，如果减少系统的调用会有多大的效果呢？

首先统计一下程序中`File.mtime()`调用了多少次。在 sort 方法中，如果给出了程序块`{...}`为了排序，每次比较元素时都要调用次块，所以程序块的调用次数比元素的个数要多很多。结果发现比较元素时程序块执行了
78270 次。为了比较 4556 个元素，就调用了 78270 次，太频繁了，美执行一次程序块，都要调用两次`File.mtime()`，总体上要调用 156540 次。

排序任务繁重时，典型的对策是使用施瓦茨变换（Schwarzian Transform），这是 Randal Schwarz 设计的告诉排序算法，先计算出比较用的值，避免比较计算重复进行，施瓦茨变换按以下几个步骤执行

1.  对排序对象的各个元素，计算比较用的值，与元素本身配对，组成一个数组（每个元素是一个二元数组）
2.  将此数组按照以上计算的比较有用值进行比较
3.  从排序后数组的数组中，取出以前的元素

上述步骤可以用一下代码表示

```ruby
Dir.entries(".").map{|x| [x,File.mtime(x)]}
  .sort{|a,b| a[1] <=> b[1]}
  .map{|x| x[0]}
```

稍微有点繁琐，事实上，施瓦茨变换已经内嵌到 sort_by 方法中，使用 sort_by 的程序如下：

```ruby
Dir.entries(".").sort_by{|a| File.mtime(a)}
```

再次测试执行时间

![](http://ogbkru1bq.bkt.clouddn.com/1537514829.png)

总执行时间从 4.624 秒减少到 0.263 秒，用户消费时间从 3.590 秒减少到 0.220 秒，系统时间从 0.850 减少到 0.050 秒，大体上快了 17 倍，用其他方式测定`File.mtime()`执行的次数为 4556 次，大约减少最初的 1/34.

施瓦茨变换通过事先保存反复计算的值来削减了计算量。这是一种成为 Memoize 的高速技术，在计算中，时间和空间可以交换，保存计算结果要占用多余的内存，作为回报能够节省时间。Memoize 在各种情况下都可以用于提高速度。

### 只需改善瓶颈

性能优化中，“因为是排序，所以就用施瓦茨变换”这总条件反射式的对策并非总管用，大到一定程度的程序，问题是不是真的在于排序部分，判断起来并不容易，为了合理的提高速度，确立恰当的策略是很重要的。

为此必须首先理解帕雷托法则。帕雷托法则又称为 80/20 法则，即 80%的数值是由 20%的构成要素产生的。19 世纪后半叶有意大利经济学家发现而得名。有帕雷托法则可知，有 20%的努力可以得到巨大的回报，80%的努力得不到多少回报,在得不到回报的地方，无论多努力都是徒劳的。

Donald Knuth 也提到，通常一半以上的执行时间都耗费在程序中不到 4%的部分。

这些耗费了大半以上的执行时间的部分成为瓶颈。对于瓶颈以外的部分，不管下了多大的努力都是白费。对于值耗费总时间 1%的部分，废了半天功夫，即使处理时间缩短了 50%，总执行时间也就缩短了 0.5%，0.5%的速度上的改善，恐怕还抵不上测试的误差。反过来，在耗费 80%执行时间的部分，就算执行速度提高 20%，总执行时间就会提高 16%。

改善瓶颈是性能优化中最最基本的，不限确认瓶颈就先高速化是万万不行的。

### 发现瓶颈的工具

在 ruby 中有个工具可以帮助我们快速的发现瓶颈所在——profiler。在 ruby 执行中附加了-rprofile 选项，这样就可以利用 profiler 了，可以使用下面的方式执行：

```shell
% ruby -rprofile xxx.rb
```

程序的执行结果，以及每列的含义如图：

![](http://ogbkru1bq.bkt.clouddn.com/1537517334.png)

![](http://ogbkru1bq.bkt.clouddn.com/1537517365.png)

从图中的结果来看，File.mtime()被调用了 156540 次，占总时间的 41%，这个就是瓶颈。

再看一下 sort_by 的执行结果

![](http://ogbkru1bq.bkt.clouddn.com/1537517685.png)

### profiler 本身成了累赘

使用 profiler 让程序的执行时间大幅度延长，测定本身对测定结果产生了影响。所以，从结果只能判断实际状态的大体倾向
