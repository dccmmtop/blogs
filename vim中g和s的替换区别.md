---
tags: [vim]
date: 2018-08-09 11:17:50
---

### [转载](http://blog.sina.com.cn/s/blog_544f18310100yktu.html)

## global 命令形式

```vim
:h :g

:h 12.4

:[range]global/{pattern}/{command}
```

global 命令在[range]指定的文本范围内（缺省为整个文件）查找{pattern}，然后对匹
配到的行执行命令{command}，如果希望对没匹配上的行执行命令，则使用 global!或 vg
lobal 命令。

先来看 Vim 用户手册里的一个经典例子。

### 【例 1】倒序文件行（即 unix 下的 tac 命令）

```vim
:g/^/m 0
```

> 这条命令用行首标记/^/匹配文件的所有行（这是查找的一个常用技巧，如果用/./则是
> 匹配非空行，不满足本例要求），然后用 move 命令依次将每行移到第一行（第 0 行的下一
> 行），从而实现了倒序功能。

global 命令实际上是分成两步执行：首先扫描[range]指定范围内的所有行，给匹配{pa
ttern}的行打上标记；然后依次对打有标记的行执行{command}命令，如果被标记的行在
对之前匹配行的命令操作中被删除、移动或合并，则其标记自动消失，而不对该行执行
{command}命令。标记的概念很重要，以例说明。

### 【例 2】删除偶数行

```vim
:g/^/+1 d
```

> 这条命令也是匹配所有行，然后隔行删除（其中+1 用以定位于当前行的下一行）。为什
> 么是隔行呢？因为在对第一行执行+1 d 命令时删除的是第二行，而第二行虽然也被标记
> 了，但已不存在了，因此不会执行删除第三行的命令。

本例也可以用 normal 命令实现：

```vim
:%norm jdd
```

> %指定整个文件，然后依次执行普通模式下的 jdd，即下移删除一行。与 global 命令不同
> 之处在于，%norm 是按照行号顺序执行，在第一行时删除了第二行，后面的所有行号都减
> 一，因此在第二行执行 jdd 时删除的是原来的第四行。也就是说，global 命令是通过偶数
> 行标记的消失实现的，而 normal 命令是通过后续行的自动前移实现的。

### 【例 3】删除奇数行

```vim
:g/^/d|m.
```

> 光是:g/^/d 显然不行，这会删除所有行，我们需要用 move 命令把偶数行的标记去掉。当
> 然，本例可以很简单的转换成【例 2】，在此只是用来强调标记的概念。

本例若想用 normal 命令实现比较有意思，%norm dd 也同样会删除整个文件，%norm jkdd
就可以，我不知道两者为什么不同，可能和 normal 命令内部的运行机制有关。

## global 与 substitute

```vim
:h 10.4

:helpg ms-word\c
```

不少 vimmer 觉得这两个命令差不多，的确，它们的形式很相似，都是要进行查找匹配，
只不过 substitute 执行的是替换而 global 执行的其它命令（当然，substitute 缺省的[r
ange]是当前行，这点也不同）。先看两个例子，体会一下:s 和:g 不同的思维方式。

### 【例 4】double 所有行

```vim
:%s/.\*/&\r&/

:g/^/t.
```

substitue 是查找任意行，然后替换为两行夹回车；global 是将每一行复制（:t 就是:co
py）到自己下面，更加清晰明了。

### 【例 5】把以回车排版、以空行分段的文本变成以回车分段的文本

很多 txt 格式的 ebook，以及像 vim help 这样的文本，每行的字符数受限，段之间用空行
分隔。若把它们拷贝到 word 里，那些硬回车和空行就比较讨厌了，虽然 word 里也有自动
调整格式的功能，不过在 Vim 里搞定更是小菜一碟。先看看用替换如何实现。

```vim
:s/\n\n\@!/ /
```

\n\n\@!是查找后面不跟回车的回车（关于\@!的用法请:h /\@!，在此不多说了），然后
替换为空格，也就是去掉用于排版的回车。global 命令则完全是另一种思路。

```vim
:g/./,/^$/j
```

> /./标记非空行，/^$/查找其后的空行，然后对二者之间的行进行合并操作。也许有人会
> 问，段中的每一行会不会都执行了 j 命令？前面已经说过，在之前操作中消失掉的标记行
> 不执行操作命令，在处理每段第一行时已经把段内的其余行都合并了，所以每段只会执
> 行一次 j 命令。这条命令使用 global 标记做为[range]的起始行，这样的用法后面还会详
> 述。

global 经常与 substitute 组合使用，用前者定位满足一定条件的行，用后者在这些行中
进行查找替换。如：

### 【例 6】将 aaa 替换成 bbb，除非该行中有 ccc 或者 ddd

```vim
:v/ccc\|ddd/s/aaa/bbb/g
```

### 【例 7】将 aaa 替换成 bbb，条件是该行中有 ccc 但不能有 ddd

如何写出一个匹配 aaa 并满足行内有 ccc 但不能有 ddd 的正则表达式？我不知道。即便能写
出来，也必定极其复杂。用 global 命令则并不困难：

```vim
:g/ccc/if getline('.') !~ 'ddd' | s/aaa/bbb/g
```

该命令首先标记匹配 ccc 的行，然后执行 if 命令（if 也是 ex 命令！），getline 函数取得
当前行，然后判断是否匹配 ddd，如果不匹配（!~的求值为 true）则执行替换。要掌握这
样的用法需要对 ex 命令、Vim 函数和表达式有一定了解才行，实际上，这条命令已经是一
个快捷版的脚本了。可能有人会想，把 g 和 v 连起来用不就行了么，可惜 global 命令不支
持（恐怕也没法支持）嵌套。

## global 标志的[range]用法

```vim
:h range
```

在 global 命令第一步中所设的标记，可以被用来为{command}命令设定各种形式的[rang
e]。在【例 2】和【例 5】中都已使用了这一技巧，灵活使用[range]，是一项重要的基本
功。先看看【例 2】和【例 3】的一般化问题。

### 【例 8】每 n 行中，删除前/后 m 行（例如，每 10 行删除前/后 3 行）

```vim
:g/^/,+2 d | ,+6 m -1

:g/^/,+6 m -1 | +1,+3 d
```

这两个命令还是利用 move 来清除保留行的标志，需要注意的是执行第二个命令时的当前

行是第一个命令寻址并执行后的位置
